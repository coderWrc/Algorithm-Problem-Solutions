# 数据结构

#### 1. 单调栈
   - [【模板】单调栈](#模板单调栈)
   - [发射站](#发射站)
   - [HISTOGRA - Largest Rectangle in a Histogram](#histogra---largest-rectangle-in-a-histogram)
#### 2. 单调队列
   * [滑动窗口 /【模板】单调队列](#滑动窗口-模板单调队列)
   * [质量检测](#质量检测)
#### 3. 并查集
   * [【模板】并查集](#模板并查集)

# [【模板】单调栈](https://www.luogu.com.cn/problem/P5788)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

const int N = 3e6 + 10;

int n, a[N], ans[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];

	stack<int> st;
	for (int i = n; i >= 1; i--)
	{
		while (st.size() && a[st.top()] <= a[i]) st.pop();
		if (st.size()) ans[i] = st.top();
		st.push(i);
	}

	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';

	return 0;
}
```
# [发射站](https://www.luogu.com.cn/problem/P1901)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

const int N = 1e6 + 10;

int n, h[N], v[N];
int sum[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> h[i] >> v[i];

	stack<int> st;

	// 找左边
	for (int i = 1; i <= n; i++)
	{
		while (st.size() && h[st.top()] <= h[i]) st.pop(); // 找到离它最近且比它高的发射站
		if (st.size()) sum[st.top()] += v[i];
		st.push(i);
	}

	while (st.size()) st.pop(); // 清空

	// 找右边
	for (int i = n; i >= 1; i--)
	{
		while (st.size() && h[st.top()] <= h[i]) st.pop();
		if (st.size()) sum[st.top()] += v[i];
		st.push(i);
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, sum[i]);
	cout << ans << endl;

	return 0;
}
```
# [HISTOGRA - Largest Rectangle in a Histogram](https://www.luogu.com.cn/problem/SP1805)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, h[N];
int len[N];

int main()
{
	while (cin >> n, n)
	{
		for (int i = 1; i <= n; i++) cin >> h[i];

		stack<int> st;

		// 向左延伸
		for (int i = 1; i <= n; i++)
		{
			while (st.size() && h[st.top()] >= h[i]) st.pop();
			if (st.size()) len[i] = i - st.top();
			else len[i] = i;
			st.push(i);
		}

		while (st.size()) st.pop();

		// 向右延伸
		for (int i = n; i >= 1; i--)
		{
			while (st.size() && h[st.top()] >= h[i]) st.pop();
			if (st.size()) len[i] += st.top() - i;
			else len[i] += n + 1 - i;
			st.push(i);
		}

		LL ans = 0;
		for (int i = 1; i <= n; i++) ans = max(ans, (len[i] - 1) * h[i] * 1LL);

		cout << ans << endl;
	}
	

	return 0;
}
```
# [滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)
[top](#2-单调队列)
```
#include <iostream>
#include <deque>

using namespace std;

const int N = 1e6 + 10;

int n, a[N], k;

int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];

	deque<int> q; // 存下标
	for (int i = 1; i <= n; i++)
	{
		while (q.size() && a[q.back()] >= a[i]) q.pop_back();
		q.push_back(i);
		while (q.back() - q.front() >= k) q.pop_front();
		if (i >= k) cout << a[q.front()] << ' ';
	}
	cout << endl;
	q.clear();
	for (int i = 1; i <= n; i++)
	{
		while (q.size() && a[q.back()] <= a[i]) q.pop_back();
		q.push_back(i);
		while (q.back() - q.front() >= k) q.pop_front();
		if (i >= k) cout << a[q.front()] << ' ';
	}


	return 0;
}
```
# [质量检测](https://www.luogu.com.cn/problem/P2251)
[top](#2-单调队列)
```
#include <iostream>
#include <deque>

using namespace std;

const int N = 1e6 + 10;

int n, m;
int a[N];

int main()
{
	cin >> n >> m;
	deque<int> q;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		while (q.size() && a[q.back()] >= a[i]) q.pop_back();
		q.push_back(i);
		while (q.back() - q.front() >= m) q.pop_front();
		if (i >= m) cout << a[q.front()] << endl;
	}

	return 0;
}
```
# [【模板】并查集](https://www.luogu.com.cn/problem/P3367)
[top](#3-并查集)
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n, m;
int fa[N];

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) fa[i] = i;
	while (m--)
	{
		int z, x, y; cin >> z >> x >> y;

		if (z == 1)
		{
			int fx = find(x);
			int fy = find(y);
			fa[fx] = fy;
		}
		else
		{
			if (find(x) == find(y)) cout << 'Y' << endl;
			else cout << 'N' << endl;
		}
	}

	return 0;
}
```
