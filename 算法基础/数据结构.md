# 数据结构

#### 1. 单调栈
   * [【模板】单调栈](#模板单调栈)
   * [发射站](#发射站)
   * [HISTOGRA - Largest Rectangle in a Histogram](#histogra---largest-rectangle-in-a-histogram)


#### 2. 单调队列
   * [滑动窗口 /【模板】单调队列](#滑动窗口-模板单调队列)


# [【模板】单调栈](https://www.luogu.com.cn/problem/P5788)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

const int N = 3e6 + 10;

int n, a[N], ans[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];

	stack<int> st;
	for (int i = n; i >= 1; i--)
	{
		while (st.size() && a[st.top()] <= a[i]) st.pop();
		if (st.size()) ans[i] = st.top();
		st.push(i);
	}

	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';

	return 0;
}
```
# [发射站](https://www.luogu.com.cn/problem/P1901)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

const int N = 1e6 + 10;

int n, h[N], v[N];
int sum[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> h[i] >> v[i];

	stack<int> st;

	// 找左边
	for (int i = 1; i <= n; i++)
	{
		while (st.size() && h[st.top()] <= h[i]) st.pop(); // 找到离它最近且比它高的发射站
		if (st.size()) sum[st.top()] += v[i];
		st.push(i);
	}

	while (st.size()) st.pop(); // 清空

	// 找右边
	for (int i = n; i >= 1; i--)
	{
		while (st.size() && h[st.top()] <= h[i]) st.pop();
		if (st.size()) sum[st.top()] += v[i];
		st.push(i);
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, sum[i]);
	cout << ans << endl;

	return 0;
}
```
# [HISTOGRA - Largest Rectangle in a Histogram](https://www.luogu.com.cn/problem/SP1805)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, h[N];
int len[N];

int main()
{
	while (cin >> n, n)
	{
		for (int i = 1; i <= n; i++) cin >> h[i];

		stack<int> st;

		// 向左延伸
		for (int i = 1; i <= n; i++)
		{
			while (st.size() && h[st.top()] >= h[i]) st.pop();
			if (st.size()) len[i] = i - st.top();
			else len[i] = i;
			st.push(i);
		}

		while (st.size()) st.pop();

		// 向右延伸
		for (int i = n; i >= 1; i--)
		{
			while (st.size() && h[st.top()] >= h[i]) st.pop();
			if (st.size()) len[i] += st.top() - i;
			else len[i] += n + 1 - i;
			st.push(i);
		}

		LL ans = 0;
		for (int i = 1; i <= n; i++) ans = max(ans, (len[i] - 1) * h[i] * 1LL);

		cout << ans << endl;
	}
	

	return 0;
}
```
# [滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)
[top](#2-单调队列)
