# 数据结构

#### 1. 单调栈
   - [【模板】单调栈](#模板单调栈)
   - [发射站](#发射站)
   - [HISTOGRA - Largest Rectangle in a Histogram](#histogra---largest-rectangle-in-a-histogram)
#### 2. 单调队列
   * [滑动窗口 /【模板】单调队列](#滑动窗口-模板单调队列)
   * [质量检测](#质量检测)
#### 3. 并查集
   * [【模板】并查集](#模板并查集)
   * [亲戚](#亲戚)
   * [[USACO10OCT] Lake Counting S](#usaco10oct-lake-counting-s)
   * [[NOI2015] 程序自动分析](#noi2015-程序自动分析)
#### 4. 扩展域并查集
   * [[BalticOI 2003] 团伙](#balticoi-2003-团伙)


# [【模板】单调栈](https://www.luogu.com.cn/problem/P5788)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

const int N = 3e6 + 10;

int n, a[N], ans[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];

	stack<int> st;
	for (int i = n; i >= 1; i--)
	{
		while (st.size() && a[st.top()] <= a[i]) st.pop();
		if (st.size()) ans[i] = st.top();
		st.push(i);
	}

	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';

	return 0;
}
```
# [发射站](https://www.luogu.com.cn/problem/P1901)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

const int N = 1e6 + 10;

int n, h[N], v[N];
int sum[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> h[i] >> v[i];

	stack<int> st;

	// 找左边
	for (int i = 1; i <= n; i++)
	{
		while (st.size() && h[st.top()] <= h[i]) st.pop(); // 找到离它最近且比它高的发射站
		if (st.size()) sum[st.top()] += v[i];
		st.push(i);
	}

	while (st.size()) st.pop(); // 清空

	// 找右边
	for (int i = n; i >= 1; i--)
	{
		while (st.size() && h[st.top()] <= h[i]) st.pop();
		if (st.size()) sum[st.top()] += v[i];
		st.push(i);
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, sum[i]);
	cout << ans << endl;

	return 0;
}
```
# [HISTOGRA - Largest Rectangle in a Histogram](https://www.luogu.com.cn/problem/SP1805)
[top](#1-单调栈)
```
#include <iostream>
#include <stack>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, h[N];
int len[N];

int main()
{
	while (cin >> n, n)
	{
		for (int i = 1; i <= n; i++) cin >> h[i];

		stack<int> st;

		// 向左延伸
		for (int i = 1; i <= n; i++)
		{
			while (st.size() && h[st.top()] >= h[i]) st.pop();
			if (st.size()) len[i] = i - st.top();
			else len[i] = i;
			st.push(i);
		}

		while (st.size()) st.pop();

		// 向右延伸
		for (int i = n; i >= 1; i--)
		{
			while (st.size() && h[st.top()] >= h[i]) st.pop();
			if (st.size()) len[i] += st.top() - i;
			else len[i] += n + 1 - i;
			st.push(i);
		}

		LL ans = 0;
		for (int i = 1; i <= n; i++) ans = max(ans, (len[i] - 1) * h[i] * 1LL);

		cout << ans << endl;
	}
	

	return 0;
}
```
# [滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)
[top](#2-单调队列)
```
#include <iostream>
#include <deque>

using namespace std;

const int N = 1e6 + 10;

int n, a[N], k;

int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];

	deque<int> q; // 存下标
	for (int i = 1; i <= n; i++)
	{
		while (q.size() && a[q.back()] >= a[i]) q.pop_back();
		q.push_back(i);
		while (q.back() - q.front() >= k) q.pop_front();
		if (i >= k) cout << a[q.front()] << ' ';
	}
	cout << endl;
	q.clear();
	for (int i = 1; i <= n; i++)
	{
		while (q.size() && a[q.back()] <= a[i]) q.pop_back();
		q.push_back(i);
		while (q.back() - q.front() >= k) q.pop_front();
		if (i >= k) cout << a[q.front()] << ' ';
	}


	return 0;
}
```
# [质量检测](https://www.luogu.com.cn/problem/P2251)
[top](#2-单调队列)
```
#include <iostream>
#include <deque>

using namespace std;

const int N = 1e6 + 10;

int n, m;
int a[N];

int main()
{
	cin >> n >> m;
	deque<int> q;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		while (q.size() && a[q.back()] >= a[i]) q.pop_back();
		q.push_back(i);
		while (q.back() - q.front() >= m) q.pop_front();
		if (i >= m) cout << a[q.front()] << endl;
	}

	return 0;
}
```
# [【模板】并查集](https://www.luogu.com.cn/problem/P3367)
[top](#3-并查集)
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n, m;
int fa[N];

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) fa[i] = i;
	while (m--)
	{
		int z, x, y; cin >> z >> x >> y;

		if (z == 1)
		{
			int fx = find(x);
			int fy = find(y);
			fa[fx] = fy;
		}
		else
		{
			if (find(x) == find(y)) cout << 'Y' << endl;
			else cout << 'N' << endl;
		}
	}

	return 0;
}
```
# [亲戚](https://www.luogu.com.cn/problem/P1551)
[top](#3-并查集)
```
#include <iostream>

using namespace std;

const int N = 5010;;

int n, m, p;
int fa[N];

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void un(int x, int y)
{
	int fx = find(x);
	int fy = find(y);

	fa[fx] = fy;
}

int main()
{
	cin >> n >> m >> p;
	for (int i = 1; i <= n; i++) fa[i] = i;
	while (m--)
	{
		int x, y; cin >> x >> y;
		un(x, y);
	}
	while (p--)
	{
		int x, y; cin >> x >> y;
		if (find(x) == find(y)) cout << "Yes" << endl;
		else cout << "No" << endl;
	}

	return 0;
}
```
# [[USACO10OCT] Lake Counting S](https://www.luogu.com.cn/problem/P1596)
[top](#3-并查集)
```
#include <iostream>

using namespace std;

const int N = 110;

int n, m;
char a[N][N];
int fa[N * N];

int dx[4] = { 0, 1, 1, 1 };
int dy[4] = { 1, 1, 0, -1 };

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void un(int x, int y)
{
	fa[find(x)] = find(y);
}

int main()
{
	cin >> n >> m;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> a[i][j];

	for (int i = 0; i < n * m; i++) fa[i] = i;

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (a[i][j] == '.') continue;
			for (int k = 0; k < 4; k++)
			{
				int x = i + dx[k], y = j + dy[k];
				if (y >= 0 && a[x][y] == 'W') un(x * m + y, i * m + j);
			}
		}
	}

	int ans = 0;
	for (int i = 0; i < n * m; i++)
	{
		int x = i / m, y = i % m;
		if (a[x][y] == 'W' && fa[i] == i) ans++;
	}
	cout << ans << endl;

	return 0;
}
```
# [[NOI2015] 程序自动分析](https://www.luogu.com.cn/problem/P1955)
[top](#3-并查集)
```
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 1e5 + 10;

int fa[N * 2];

struct node
{
	int i, j, e;
}a[N];

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void un(int x, int y)
{
	fa[find(x)] = find(y);
}

bool issame(int x, int y)
{
	return find(x) == find(y);
}

bool solve()
{
	int n; cin >> n;
	int pos = 0;
	int disc[N * 2];
	for (int k = 1; k <= n; k++)
	{
		cin >> a[k].i >> a[k].j >> a[k].e;
		disc[++pos] = a[k].i; disc[++pos] = a[k].j;
	}

	// 离散化
	sort(disc + 1, disc + 1 + pos);
	unordered_map<int, int> mp;
	int cnt = 0;
	for (int k = 1; k <= pos; k++)
	{
		int x = disc[k];
		if (mp.count(x)) continue;
		mp[x] = ++cnt;
	}

	// 并查集
	// 初始化
	for (int k = 1; k <= cnt; k++) fa[k] = k;

	// 把所有相等的信息，用并查集维护起来
	for (int k = 1; k <= n; k++)
	{
		int i = a[k].i, j = a[k].j, e = a[k].e;
		if (e == 1) (un(mp[i], mp[j]));
	}

	// 拿出不相等的信息，判断是否合法
	for (int k = 1; k <= n; k++)
	{
		int i = a[k].i, j = a[k].j, e = a[k].e;
		if (!e && issame(mp[i], mp[j])) return false;
	}

	return true;
}

int main()
{
	int t; cin >> t;
	while (t--)
	{
		if (solve()) cout << "YES" << endl;
		else cout << "NO" << endl;
	}

	return 0;
}
```
# [[BalticOI 2003] 团伙](https://www.luogu.com.cn/problem/P1892)
[top](#4-扩展域并查集)
```
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int fa[N * 2];

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void un(int x, int y)
{
	fa[find(y)] = find(x);
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n * 2; i++) fa[i] = i;
	while (m--)
	{
		char op; int x, y;
		cin >> op >> x >> y;
		if (op == 'F') un(x, y);
		else
		{
			un(x, y + n);
			un(y, x + n);
		}
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) if (fa[i] == i) ans++;
	cout << ans << endl;

	return 0;
}
```
