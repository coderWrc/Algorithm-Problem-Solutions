# 图论基础

#### 1. 最小生成树
   * [【模板】最小生成树](#模板最小生成树)




# [【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
[top](#1-最小生成树)  
>所有⽣成树中权值之和最⼩的树称为最⼩⽣成树
  
>Prim 算法 - 邻接矩阵
```
#include <iostream>
#include <cstring>

using namespace std;

const int N = 5010, INF = 0x3f3f3f3f;

int n, m; // n 个结点，m 条无向边
int edges[N][N]; // 邻接矩阵存储图

int dist[N]; // 某个点距离生成树的最短距离
bool st[N]; // 标记哪些点已经加入到生成树中

int prim()
{
	// 初始化
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;

	int ret = 0;
	for (int i = 1; i <= n; i++) // 循环加入 n 个点
	{
		// 1. 找最近点
		int t = 0;
		for (int j = 1; j <= n; j++)
			if (!st[j] && dist[j] < dist[t])
				t = j;

		// 判断是否联通
		if (dist[t] == INF) return INF;
		st[t] = true;
		ret += dist[t];

		// 2. 更新距离
		for (int j = 1; j <= n; j++) // 枚举 t 能走到哪
			dist[j] = min(dist[j], edges[t][j]);
	}

	return ret;
}

int main()
{
	cin >> n >> m;

	// 初始化 邻接矩阵
	memset(edges, 0x3f, sizeof edges);

	for (int i = 1; i <= m; i++)
	{
		int x, y, z; cin >> x >> y >> z;

		// 注意重边的情况
		edges[x][y] = edges[y][x] = min(edges[x][y], z);
	}

	int ret = prim();
	if (ret == INF) cout << "orz" << endl;
	else cout << ret << endl;

	return 0;
}
```
