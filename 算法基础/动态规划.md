# 动态规划

#### 1. 入门：从记忆化搜索到动态规划
   * [[GESP样题 六级] 下楼梯](#gesp样题-六级-下楼梯)
   * [[IOI 1994] 数字三角形 Number Triangles](#ioi-1994-数字三角形-number-triangles)


#### 2. 线性 dp
   1. 基础线性 dp
      * [台阶问题](#台阶问题)
      * [最大子段和](#最大子段和)
      * [[NOIP 2008 普及组] 传球游戏](#noip-2008-普及组-传球游戏)

   2. 路径类 dp


   3. 经典线性 dp



#### 3. 背包问题


#### 4. 区间 dp



# [[GESP样题 六级] 下楼梯](https://www.luogu.com.cn/problem/P10250)
[top](#1-入门从记忆化搜索到动态规划)  
码一：
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 65;

int n;
LL f[N]; // 当有 i 个台阶，有 f[i] 种方案

int main()
{
	cin >> n;

	// 初始化
	f[0] = 1; f[1] = 1; f[2] = 2;

	for (int i = 3; i <= n; i++)
	{
		f[i] = f[i - 1] + f[i - 2] + f[i - 3];
	}

	cout << f[n] << endl;

	return 0;
}
```
>空间优化 - 滚动数组
码二：
```
#include <iostream>

using namespace std;

typedef long long LL;

int n;

int main()
{
	cin >> n;

	LL a = 1, b = 1, c = 2;

	for (int i = 3; i <= n; i++)
	{
		LL t = a + b + c;
		a = b;
		b = c;
		c = t;
	}

	if (n == 1) cout << b << endl;
	else cout << c << endl;

	return 0;
}
```
# [[IOI 1994] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)
[top](#1-入门从记忆化搜索到动态规划)  
码一：
```
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int f[N][N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= i; j++)
		{
			int x; cin >> x;
			f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + x;
		}
	}

	int ans = 0;
	for (int j = 1; j <= n; j++) ans = max(ans, f[n][j]);
	cout << ans << endl;

	return 0;
}
```
码二：
```
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int f[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j >= 1; j--)
		{
			int x; cin >> x;
			f[j] = max(f[j - 1], f[j]) + x;
		}
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
	cout << ans << endl;

	return 0;
}
```
# [台阶问题](https://www.luogu.com.cn/problem/P1192)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10, MOD = 100003;

int n, k;
int f[N];

int main()
{
	cin >> n >> k;

	f[0] = 1;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= k && i - j >= 0; j++)
		{
			f[i] = (f[i] + f[i - j]) % MOD;
		}
	}

	cout << f[n] << endl;

	return 0;
}
```
# [最大子段和](https://www.luogu.com.cn/problem/P1115)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n;
int f[N];

int main()
{
	cin >> n;
	int ans = -1e4;
	for (int i = 1; i <= n; i++)
	{
		int x; cin >> x;
		f[i] = max(x, x + f[i - 1]);
		ans = max(ans, f[i]);
	}

	cout << ans << endl;

	return 0;
}
```
# [[NOIP 2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 35;

int n, m; // 同学数，传球数
int f[N][N]; // f[i][j] 表示传递了 i 次后，落在 j 号 同学的方法数

int main()
{
	cin >> n >> m;

	f[0][1] = 1;

	for (int i = 1; i <= m; i++)
	{
		f[i][1] = f[i - 1][n] + f[i - 1][2];

		for (int j = 2; j < n; j++)
		{
			f[i][j] = f[i - 1][j - 1] + f[i - 1][j + 1];
		}

		f[i][n] = f[i - 1][n - 1] + f[i - 1][1];
	}

	cout << f[m][1] << endl;

	return 0;
}
```
