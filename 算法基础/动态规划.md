# 动态规划

#### 1. 入门：从记忆化搜索到动态规划
   * [[GESP样题 六级] 下楼梯](#gesp样题-六级-下楼梯)
   * [[IOI 1994] 数字三角形 Number Triangles](#ioi-1994-数字三角形-number-triangles)


#### 2. 线性 dp
   1. 基础线性 dp
      * [台阶问题](#台阶问题)
      * [最大子段和](#最大子段和)
      * [[NOIP 2008 普及组] 传球游戏](#noip-2008-普及组-传球游戏)
      * [[NOIP 2010 提高组] 乌龟棋](#noip-2010-提高组-乌龟棋)

   2. 路径类 dp
      * [矩阵的最小路径和](#矩阵的最小路径和)

   3. 经典线性 dp



#### 3. 背包问题


#### 4. 区间 dp



# [[GESP样题 六级] 下楼梯](https://www.luogu.com.cn/problem/P10250)
[top](#1-入门从记忆化搜索到动态规划)  
码一：
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 65;

int n;
LL f[N]; // 当有 i 个台阶，有 f[i] 种方案

int main()
{
	cin >> n;

	// 初始化
	f[0] = 1; f[1] = 1; f[2] = 2;

	for (int i = 3; i <= n; i++)
	{
		f[i] = f[i - 1] + f[i - 2] + f[i - 3];
	}

	cout << f[n] << endl;

	return 0;
}
```
>空间优化 - 滚动数组
码二：
```
#include <iostream>

using namespace std;

typedef long long LL;

int n;

int main()
{
	cin >> n;

	LL a = 1, b = 1, c = 2;

	for (int i = 3; i <= n; i++)
	{
		LL t = a + b + c;
		a = b;
		b = c;
		c = t;
	}

	if (n == 1) cout << b << endl;
	else cout << c << endl;

	return 0;
}
```
# [[IOI 1994] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)
[top](#1-入门从记忆化搜索到动态规划)  
码一：
```
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int f[N][N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= i; j++)
		{
			int x; cin >> x;
			f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + x;
		}
	}

	int ans = 0;
	for (int j = 1; j <= n; j++) ans = max(ans, f[n][j]);
	cout << ans << endl;

	return 0;
}
```
码二：
```
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int f[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j >= 1; j--)
		{
			int x; cin >> x;
			f[j] = max(f[j - 1], f[j]) + x;
		}
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
	cout << ans << endl;

	return 0;
}
```
# [台阶问题](https://www.luogu.com.cn/problem/P1192)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10, MOD = 100003;

int n, k;
int f[N];

int main()
{
	cin >> n >> k;

	f[0] = 1;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= k && i - j >= 0; j++)
		{
			f[i] = (f[i] + f[i - j]) % MOD;
		}
	}

	cout << f[n] << endl;

	return 0;
}
```
# [最大子段和](https://www.luogu.com.cn/problem/P1115)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n;
int f[N];

int main()
{
	cin >> n;
	int ans = -1e4;
	for (int i = 1; i <= n; i++)
	{
		int x; cin >> x;
		f[i] = max(x, x + f[i - 1]);
		ans = max(ans, f[i]);
	}

	cout << ans << endl;

	return 0;
}
```
# [[NOIP 2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 35;

int n, m; // 同学数，传球数
int f[N][N]; // f[i][j] 表示传递了 i 次后，落在 j 号 同学的方法数

int main()
{
	cin >> n >> m;

	f[0][1] = 1;

	for (int i = 1; i <= m; i++)
	{
		f[i][1] = f[i - 1][n] + f[i - 1][2];

		for (int j = 2; j < n; j++)
		{
			f[i][j] = f[i - 1][j - 1] + f[i - 1][j + 1];
		}

		f[i][n] = f[i - 1][n - 1] + f[i - 1][1];
	}

	cout << f[m][1] << endl;

	return 0;
}
```
# [[NOIP 2010 提高组] 乌龟棋](https://www.luogu.com.cn/problem/P1541)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 360, M = 45;

int n, m;
int sc[N], cnt[5];
int f[M][M][M][M]; // 1234 的卡片分别用了 abcd 张时，此时的最大分数

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> sc[i];
	for (int i = 1; i <= m; i++)
	{
		int x; cin >> x;
		cnt[x]++;
	}

	// 初始化
	f[0][0][0][0] = sc[1];

	for (int a = 0; a <= cnt[1]; a++)
		for (int b = 0; b <= cnt[2]; b++)
			for (int c = 0; c <= cnt[3]; c++)
				for (int d = 0; d <= cnt[4]; d++)
				{
					int cur = 1 + a + b * 2 + c * 3 + d * 4;
					int& t = f[a][b][c][d];
					if (a) t = max(t, f[a - 1][b][c][d] + sc[cur]);
					if (b) t = max(t, f[a][b - 1][c][d] + sc[cur]);
					if (c) t = max(t, f[a][b][c - 1][d] + sc[cur]);
					if (d) t = max(t, f[a][b][c][d - 1] + sc[cur]);
				}

	cout << f[cnt[1]][cnt[2]][cnt[3]][cnt[4]] << endl;

	return 0;
}
```
# [矩阵的最小路径和](https://www.nowcoder.com/practice/38ae72379d42471db1c537914b06d48e?tpId=230&tqId=39755&ru=/exam/oj)
[top](#2-线性-dp)
```
#include <iostream>
#include <cstring>

using namespace std;

const int N = 510;

int n, m;
int f[N][N];

int main()
{
    cin >> n >> m;
    memset(f, 0x3f, sizeof f);
    f[0][1] = 0;
    
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int x; cin >> x;
            f[i][j] = min(f[i - 1][j], f[i][j - 1]) + x;
        }
    }

    cout << f[n][m] << endl;

    return 0;
}
```
