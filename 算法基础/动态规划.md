# 动态规划

#### 1. 入门：从记忆化搜索到动态规划
   * [[GESP样题 六级] 下楼梯](#gesp样题-六级-下楼梯)
   * [[IOI 1994] 数字三角形 Number Triangles](#ioi-1994-数字三角形-number-triangles)


#### 2. 线性 dp
   1. 基础线性 dp
      * [台阶问题](#台阶问题)
      * [最大子段和](#最大子段和)
      * [[NOIP 2008 普及组] 传球游戏](#noip-2008-普及组-传球游戏)
      * [[NOIP 2010 提高组] 乌龟棋](#noip-2010-提高组-乌龟棋)

   2. 路径类 dp
      * [矩阵的最小路径和](#矩阵的最小路径和)
      * [「木」迷雾森林](#木迷雾森林)
      * [[NOIP 2002 普及组] 过河卒](#noip-2002-普及组-过河卒)
      * [[NOIP 2000 提高组] 方格取数](#noip-2000-提高组-方格取数)

   3. 经典线性 dp
      * [最长上升子序列](#最长上升子序列)
      * [【模板】最长上升子序列](#模板最长上升子序列)
      * [[NOIP 2004 提高组] 合唱队形](#noip-2004-提高组-合唱队形)
      * [牛可乐和最长公共子序列](#牛可乐和最长公共子序列)
      * [【模板】最长公共子序列](#模板最长公共子序列)
      * [编辑距离](#编辑距离)


#### 3. 背包问题


#### 4. 区间 dp



# [[GESP样题 六级] 下楼梯](https://www.luogu.com.cn/problem/P10250)
[top](#1-入门从记忆化搜索到动态规划)  
码一：
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 65;

int n;
LL f[N]; // 当有 i 个台阶，有 f[i] 种方案

int main()
{
	cin >> n;

	// 初始化
	f[0] = 1; f[1] = 1; f[2] = 2;

	for (int i = 3; i <= n; i++)
	{
		f[i] = f[i - 1] + f[i - 2] + f[i - 3];
	}

	cout << f[n] << endl;

	return 0;
}
```
>空间优化 - 滚动数组
码二：
```
#include <iostream>

using namespace std;

typedef long long LL;

int n;

int main()
{
	cin >> n;

	LL a = 1, b = 1, c = 2;

	for (int i = 3; i <= n; i++)
	{
		LL t = a + b + c;
		a = b;
		b = c;
		c = t;
	}

	if (n == 1) cout << b << endl;
	else cout << c << endl;

	return 0;
}
```
# [[IOI 1994] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)
[top](#1-入门从记忆化搜索到动态规划)  
码一：
```
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int f[N][N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= i; j++)
		{
			int x; cin >> x;
			f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + x;
		}
	}

	int ans = 0;
	for (int j = 1; j <= n; j++) ans = max(ans, f[n][j]);
	cout << ans << endl;

	return 0;
}
```
码二：
```
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int f[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j >= 1; j--)
		{
			int x; cin >> x;
			f[j] = max(f[j - 1], f[j]) + x;
		}
	}

	int ans = 0;
	for (int i = 1; i <= n; i++) ans = max(ans, f[i]);
	cout << ans << endl;

	return 0;
}
```
# [台阶问题](https://www.luogu.com.cn/problem/P1192)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10, MOD = 100003;

int n, k;
int f[N];

int main()
{
	cin >> n >> k;

	f[0] = 1;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= k && i - j >= 0; j++)
		{
			f[i] = (f[i] + f[i - j]) % MOD;
		}
	}

	cout << f[n] << endl;

	return 0;
}
```
# [最大子段和](https://www.luogu.com.cn/problem/P1115)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n;
int f[N];

int main()
{
	cin >> n;
	int ans = -1e4;
	for (int i = 1; i <= n; i++)
	{
		int x; cin >> x;
		f[i] = max(x, x + f[i - 1]);
		ans = max(ans, f[i]);
	}

	cout << ans << endl;

	return 0;
}
```
# [[NOIP 2008 普及组] 传球游戏](https://www.luogu.com.cn/problem/P1057)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 35;

int n, m; // 同学数，传球数
int f[N][N]; // f[i][j] 表示传递了 i 次后，落在 j 号 同学的方法数

int main()
{
	cin >> n >> m;

	f[0][1] = 1;

	for (int i = 1; i <= m; i++)
	{
		f[i][1] = f[i - 1][n] + f[i - 1][2];

		for (int j = 2; j < n; j++)
		{
			f[i][j] = f[i - 1][j - 1] + f[i - 1][j + 1];
		}

		f[i][n] = f[i - 1][n - 1] + f[i - 1][1];
	}

	cout << f[m][1] << endl;

	return 0;
}
```
# [[NOIP 2010 提高组] 乌龟棋](https://www.luogu.com.cn/problem/P1541)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 360, M = 45;

int n, m;
int sc[N], cnt[5];
int f[M][M][M][M]; // 1234 的卡片分别用了 abcd 张时，此时的最大分数

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> sc[i];
	for (int i = 1; i <= m; i++)
	{
		int x; cin >> x;
		cnt[x]++;
	}

	// 初始化
	f[0][0][0][0] = sc[1];

	for (int a = 0; a <= cnt[1]; a++)
		for (int b = 0; b <= cnt[2]; b++)
			for (int c = 0; c <= cnt[3]; c++)
				for (int d = 0; d <= cnt[4]; d++)
				{
					int cur = 1 + a + b * 2 + c * 3 + d * 4;
					int& t = f[a][b][c][d];
					if (a) t = max(t, f[a - 1][b][c][d] + sc[cur]);
					if (b) t = max(t, f[a][b - 1][c][d] + sc[cur]);
					if (c) t = max(t, f[a][b][c - 1][d] + sc[cur]);
					if (d) t = max(t, f[a][b][c][d - 1] + sc[cur]);
				}

	cout << f[cnt[1]][cnt[2]][cnt[3]][cnt[4]] << endl;

	return 0;
}
```
# [矩阵的最小路径和](https://www.nowcoder.com/practice/38ae72379d42471db1c537914b06d48e?tpId=230&tqId=39755&ru=/exam/oj)
[top](#2-线性-dp)
```
#include <iostream>
#include <cstring>

using namespace std;

const int N = 510;

int n, m;
int f[N][N];

int main()
{
    cin >> n >> m;
    memset(f, 0x3f, sizeof f);
    f[0][1] = 0;
    
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int x; cin >> x;
            f[i][j] = min(f[i - 1][j], f[i][j - 1]) + x;
        }
    }

    cout << f[n][m] << endl;

    return 0;
}
```
# [「木」迷雾森林](https://ac.nowcoder.com/acm/problem/53675)
[top](#2-线性-dp)
```
#include <bits/stdc++.h>

using namespace std;

const int N = 3010;

int m, n;
int a[N][N];
int f[N][N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> m >> n; // m 行 n 列
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    
    f[m][0] = 1;
    
    for (int i = m; i >= 1; i--) {
        for (int j = 1; j <= n; j++) {
            if (!a[i][j]) {
                f[i][j] = (f[i + 1][j] + f[i][j - 1]) % 2333;
            }
        }
    }
    
    cout << f[1][n] << endl;
    
    return 0;
}
```
# [[NOIP 2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 25;

int n, m, x, y;
LL f[N][N];

bool check(int i, int j) // 看马能不能拦下过河卒
{
	return (i == x && j == y || i != x && j != y && abs(i - x) + abs(j - y) == 3);
}

int main()
{
	cin >> n >> m >> x >> y;
	n++; m++; x++; y++;

	f[0][1] = 1;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			if (check(i, j)) continue;
			f[i][j] = f[i - 1][j] + f[i][j - 1];
		}
	}

	cout << f[n][m] << endl;

	return 0;
}
```
# [[NOIP 2000 提高组] 方格取数](https://www.luogu.com.cn/problem/P1004)
[top](#2-线性-dp)  
>贪⼼ + 两次 dp 是错误的，因为两次最优不等于全局最优，可以举出反例。正解应该是同时去⾛两条路，两者相互影响，所以放在⼀起考虑。

```
#include <iostream>

using namespace std;

const int N = 15;

int n;
int a[N][N];
int f[N * 2][N][N]; // 两人同时走，走到 (i1, j1), (i2, j2) 时，取得的最大的和

int main()
{
	cin >> n;
	int x, y, v;
	while (cin >> x >> y >> v, x || y || v)
	{
		a[x][y] = v;
	}

	for (int s = 2; s <= n * 2; s++) // 从 (1, 1) 开始
	{
		for (int i1 = 1; i1 <= n; i1++) 
		{
			for (int i2 = 1; i2 <= n; i2++) 
			{
				int j1 = s - i1, j2 = s - i2;
				if (j1 <= 0 || j1 > n || j2 <= 0 || j2 > n) continue;
				
				int x = f[s - 1][i1][i2];
				x = max(x, f[s - 1][i1][i2 - 1]);
				x = max(x, f[s - 1][i1 - 1][i2]);
				x = max(x, f[s - 1][i1 - 1][i2 - 1]);

				f[s][i1][i2] = x + a[i1][j1] + a[i2][j2];
				if (i1 == i2) f[s][i1][i2] -= a[i1][j1];
			}
		}
	}

	cout << f[n * 2][n][n] << endl;

	return 0;
}
```
# [最长上升子序列](https://www.luogu.com.cn/problem/B3637)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 5010;

int n;
int a[N];
int f[N]; // 以 i 位置元素为结尾的「所有⼦序列」中，最⻓递增⼦序列的⻓度

int main()
{
	cin >> n;
	int ans = 1;
	for (int i = 1; i <= n; i++)
	{
		f[i] = 1;
		cin >> a[i];
		for (int j = 1; j < i; j++)
		{
			if (a[i] > a[j])
			{
				f[i] = max(f[i], f[j] + 1);
			}
		}
		ans = max(ans, f[i]);
	}

	cout << ans << endl;

	return 0;
}
```
# [【模板】最长上升子序列](https://ac.nowcoder.com/acm/problem/226831)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int f[N], len;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int x; cin >> x;
        // 处理边界情况
        if (len == 0 || x > f[len]) f[++len] = x;
        else
        {
            int l = 0, r = len;
            while (l + 1 < r)
            {
                int mid = l + ((r - l) >> 1);
                if (x > f[mid]) l = mid;
                else r = mid; // 找到满足 x <= f[mid] 的最小末尾
            }
            f[r] = x;
        }
    }
    
    cout << len << endl;
    
    return 0;
}
```
# [[NOIP 2004 提高组] 合唱队形](https://www.luogu.com.cn/problem/P1091)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 110;

int n;
int a[N];
int f[N], g[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];

	// 从左往右
	for (int i = 1; i <= n; i++)
	{
		f[i] = 1;
		for (int j = 1; j < i; j++)
		{
			if (a[i] > a[j])
			{
				f[i] = max(f[i], f[j] + 1);
			}
		}
	}

	// 从右往左
	for (int i = n; i >= 1; i--)
	{
		g[i] = 1;
		for (int j = n; j > i; j--)
		{
			if (a[i] > a[j])
			{
				g[i] = max(g[i], g[j] + 1);
			}
		}
	}

	int cnt = 0;
	for (int i = 1; i <= n; i++)
	{
		cnt = max(cnt, f[i] + g[i] - 1);
	}

	cout << n - cnt << endl;

	return 0;
}
```
# [牛可乐和最长公共子序列](https://ac.nowcoder.com/acm/problem/235624)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 5010;

string s, t;
int f[N][N]; // s 的 (1, i) 区间以及 t 的 (1, j) 区间内的所有的⼦序列中，最⻓公共⼦序列的⻓度

int main()
{
    while (cin >> s >> t)
    {
        int n = s.size(), m = t.size();
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                if (s[i - 1] == t[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;
                else
                {
                    f[i][j] = max(f[i][j - 1], f[i - 1][j]);
                }
            }
        }
        cout << f[n][m] << endl;
    }
    
    return 0;
}
```
# [【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)
[top](#2-线性-dp)  
>转化为最长递增子序列 (LIS) 问题
核心思想：  
如果 a 和 b 是排列（即元素唯一且长度相同），可以将 LCS 问题转化为 LIS 问题。  
具体步骤：  
用 map 数组记录 a 中每个元素的位置。例如，map[a[i]] = i 表示元素 a[i] 在 a 中的位置是 i。  
将 b 中的每个元素替换为它在 a 中的位置，得到一个新序列 c。  
对新序列 c 求 LIS，这个 LIS 的长度就是 a 和 b 的 LCS 的长度。  
```
#include <iostream>
#include <unordered_map>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N], b[N];
int f[N], len;

unordered_map<int, int> mp;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		mp[a[i]] = i;
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> b[i];
		b[i] = mp[b[i]];
	}

	for (int i = 1; i <= n; i++)
	{
		if (b[i] > f[len]) f[++len] = b[i];
		else
		{
			int l = 0, r = len;
			while (l + 1 < r)
			{
				int mid = l + ((r - l) >> 1);
				if (b[i] > f[mid]) l = mid;
				else r = mid;
			}
			f[r] = b[i];
		}
	}

	cout << len << endl;

	return 0;
}
```
# [编辑距离](https://www.luogu.com.cn/problem/P2758)
[top](#2-线性-dp)
```
#include <iostream>

using namespace std;

const int N = 2010;

string a, b;
int f[N][N]; // 把 a 字符串 [1, i] 区间的子串变成 [1, j] 区间的子串，最小的操作次数

int main()
{
	cin >> a >> b;
	int n = a.size(), m = b.size();

	// 初始化
	for (int i = 0; i <= n; i++) f[i][0] = i;
	for (int j = 0; j <= m; j++) f[0][j] = j;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			if (a[i - 1] == b[j - 1]) f[i][j] = f[i - 1][j - 1];
			else f[i][j] = min(min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1; 
		}
	}

	cout << f[n][m] << endl;

	return 0;
}
```
