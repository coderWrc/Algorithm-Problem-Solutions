# 基础算法

#### 1. 模拟
   * [多项式输出](#多项式输出)
   * [蛇形方阵](#蛇形方阵)
   * [字符串的展开](#字符串的展开)
#### 2. 高精度
   * [A+B Problem(高精)](#ab-problem高精)
   * [高精度减法](#高精度减法)
   * [A*B Problem](#ab-problem)
   * [A/B Problem](#ab-problem-1)
#### 3. 枚举
   1. 普通枚举
      * [铺地毯](#铺地毯)
      * [回文日期](#回文日期)
      * [扫雷](#扫雷)
   2. 二进制枚举
	  * [子集](#子集)
	  * [费解的开关](#费解的开关)
	  * [Even Parity](#even-parity)
#### 4. 前缀和
   * [【模板】前缀和](#模板前缀和)
   * [最大子段和](#最大子段和)
   * [【模板】二维前缀和](#模板二维前缀和)
   * [激光炸弹](#激光炸弹)
#### 5. 差分
   * [【模板】差分](#模板差分)
   * [海底高铁](#海底高铁)
   * [【模板】二维差分](#模板二维差分)
   * [地毯](#地毯)
#### 6. 双指针
   * [唯一的雪花 Unique Snowflakes](#唯一的雪花-unique-snowflakes)
   * [逛画展](#逛画展)
   * [字符串](#字符串)
   * [丢手绢](#丢手绢)
#### 7. 二分算法
   1. 二分查找
      * [在排序数组中查找元素的第一个和最后一个位置](LeetCode%20题解/LeetCode%2034.在排序数组中查找元素的第一个和最后一个位置.md) 
      * [牛可乐和魔法封印](#牛可乐和魔法封印)
      * [A-B 数对](洛谷题解/洛谷%20P1102%20A-B%20数对.md)
      * [烦恼的高考志愿](#烦恼的高考志愿)
   2. 二分答案
	  * [木材加工](#木材加工)
	  * [[COCI 2011/2012 #5] EKO / 砍树](#coci-20112012-5-eko--砍树)
	  * [[NOIP2015 提高组] 跳石头](#noip2015-提高组-跳石头)
#### 8. 贪心
   1. 简单贪心
	  * [货仓选址](#货仓选址)
	  * [最大子段和](#最大子段和)
	  * [[NOIP 2007 普及组] 纪念品分组](#noip-2007-普及组-纪念品分组)
	  * [[NOIP 2008 普及组] 排座椅](#noip-2008-普及组-排座椅)
	  * [矩阵消除游戏](#矩阵消除游戏)
   2. 推公式  
      * [[NOIP 1998 提高组] 拼数](#noip-1998-提高组-拼数)
      * [[USACO07JAN] Protecting the Flowers S](#usaco07jan-protecting-the-flowers-s)
      * [[USACO05NOV] 奶牛玩杂技](#usaco05nov-奶牛玩杂技)
   3. 哈夫曼编码
      * [【模板】哈夫曼编码](#模板哈夫曼编码)
      * [[NOIP 2004 提高组] 合并果子](#noip-2004-提高组-合并果子)
   4. 区间问题
	  * [凌乱的yyy / 线段覆盖](#凌乱的yyy--线段覆盖)
	  * [Radar Installation](#radar-installation)
	  * [[USACO07NOV] Sunscreen G](#usaco07nov-sunscreen-g)
	  * [[USACO06FEB] Stall Reservations S](#usaco06feb-stall-reservations-s)
#### 9. 倍增思想
   * [【模板】快速幂](#模板快速幂) 
   * [64位整数乘法](#64位整数乘法)
#### 10. 离散化
   * [火烧赤壁](#火烧赤壁)
   * [[HAOI2014] 贴海报](#haoi2014-贴海报)
#### 11. 递归初阶
   * [汉诺塔问题](#汉诺塔问题)
   * [占卜DIY](#占卜diy)
   * [[NOIP 2004 普及组] FBI 树](#noip-2004-普及组-fbi-树)
#### 12. 分治
   * [逆序对](#逆序对)
   * [【深基9.例4】求第 k 小的数](#深基9例4求第-k-小的数)
   * [最大子段和](#最大子段和)
   * [地毯填补问题](#地毯填补问题)
>位运算 排序 哈希集合 数学  
[只出现一次的数字](https://leetcode.cn/problems/single-number/description/)  
[丢失的数字](https://leetcode.cn/problems/missing-number/description/)  
[消失的数字](https://leetcode.cn/problems/missing-number-lcci/description/)  
   
>相向双指针  
[两数之和 || - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)  
[三数之和](LeetCode%20题解/LeetCode%2015.三数之和.md)  
   
>滑动窗口  
[长度最小的子数组](LeetCode%20题解/LeetCode%20209.长度最小的子数组.md)  
[乘积小于k的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)  
[无重复字符的最长子串](LeetCode%20题解/LeetCode%203.无重复字符的最长子串.md)  
  
>二分算法  

[正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/description/)  
[咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)  
[统计公平数对的数目](LeetCode%20题解/LeetCode%202563.统计公平数对的数目.md)   
[H 指数 ||](LeetCode%20题解/LeetCode%20275.H%20指数%20II.md)  
[爱吃香蕉的珂珂](LeetCode%20题解/LeetCode%20875.爱吃香蕉的珂珂.md)  
[完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/description/)  
[最大合金数](https://leetcode.cn/problems/maximum-number-of-alloys/description/)  
[最小化数组中的最大值](LeetCode%20题解/LeetCode%202439.最小化数组中的最大值.md)  
[礼盒的最大甜蜜度](LeetCode%20题解/LeetCode%202517.礼盒的最大甜蜜度.md)  
[每个小孩最多能分到多少糖果](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/description/)  
[两个数组间的距离值](LeetCode%20题解/LeetCode%201385.两个数组间的距离值.md)   
[使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/description/)  

## [多项式输出](https://www.luogu.com.cn/problem/P1067)  
[top](#基础算法)  
```
#include <iostream>
#include <cmath>

using namespace std;

int main()
{
	int n; cin >> n;
	for (int i = n; i >= 0; i--)
	{
		int a; cin >> a;

		if (a == 0) continue;

		if (a < 0) cout << '-';
		else if (i != n) cout << '+';

		if (abs(a) != 1 || (i == 0)) cout << abs(a);

		if (i == 0) continue;
		else if (i == 1) cout << 'x';
		else cout << "x^" << i;
	}

	return 0;
}
```

## [蛇形方阵](https://www.luogu.com.cn/problem/P5731)  
[top](#基础算法)  
```
#include <iostream>

using namespace std;

const int N = 15;

int dx[] = { 0, 1, 0, -1 };
int dy[] = { 1, 0, -1, 0 };

int arr[N][N];

int main()
{
	int n; cin >> n;
	int x = 1, y = 1;
	int pos = 0;

	for (int i = 1; i <= n * n; i++)
	{
		arr[x][y] = i;
		int a = x + dx[pos], b = y + dy[pos];
		if (a < 1 || a > n || b < 1 || b > n || arr[a][b])
		{
			pos = (pos + 1) % 4;
			a = x + dx[pos], b = y + dy[pos];
		}
		x = a, y = b;
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			printf("%3d", arr[i][j]);
		}
		puts("");
	}

	return 0;
}
```

## [字符串的展开](https://www.luogu.com.cn/problem/P1098)  
[top](#基础算法)  
```
#include <iostream>
#include <cctype>
#include <algorithm>

using namespace std;

int p1, p2, p3, n;
string s;
string ret;

void add(char left, char right)
{
	string t;

	// 遍历中间字符
	for (char ch = left + 1; ch < right; ch++)
	{
		char tmp = ch;
		// 处理p1
		if (p1 == 2 && islower(tmp)) tmp -= 32;
		else if (p1 == 3) tmp = '*';

		// 处理p2
		for (int i = 0; i < p2; i++)
		{
			t += tmp;
		}
	}

	// 处理p3
	if (p3 == 2) reverse(t.begin(), t.end());

	ret += t;
}

int main()
{
	cin >> p1 >> p2 >> p3 >> s;
	n = s.size();

	for (int i = 0; i < n; i++)\
	{
		char ch = s[i];
		if (s[i] != '-' || i == 0 || i == n - 1) ret += ch;
		else
		{
			char left = s[i - 1], right = s[i + 1];
			// 判断是否展开
			if (isdigit(left) && isdigit(right) && left < right ||
				islower(left) && islower(right) && left < right)
			{
				// 展开
				add(left, right);
			}
			else
			{
				ret += ch;
			}
		}
	}
	cout << ret << endl;

	return 0;
}
```

## [A+B Problem(高精)](https://www.luogu.com.cn/problem/P1601)  
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

void add(int c[], int a[], int b[])
{
	for (int i = 0; i < lc; i++)
	{
		c[i] += a[i] + b[i];
		c[i + 1] = c[i] / 10;
		c[i] %= 10;
	}
	if (c[lc]) lc++;
}

int main()
{
	string x, y; cin >> x >> y;

	la = x.size(); lb = y.size(); lc = max(la, lb);
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	add(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [高精度减法](https://www.luogu.com.cn/problem/P2142)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

bool cmp(string& x, string& y)
{
	if (x.size() != y.size()) return x.size() < y.size();
	return x < y;
}

void sub(int c[], int a[], int b[])
{
	for (int i = 0; i < lc; i++)
	{
		c[i] += a[i] - b[i];
		if (c[i] < 0)
		{
			c[i] += 10;
			c[i + 1] -= 1;
		}
	}
	while (lc > 1 && c[lc - 1] == 0) lc--;
}

int main()
{
	string x, y; cin >> x >> y;
	
	if (cmp(x, y))
	{
		swap(x, y);
		cout << '-';
	}

	la = x.size(); lb = y.size(); lc = max(la, lb);
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	sub(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [A*B Problem](https://www.luogu.com.cn/problem/P1303)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

int a[N], b[N], c[N];
int la, lb, lc;

void mul(int c[], int a[], int b[])
{
	for (int i = 0; i < la; i++)
	{
		for (int j = 0; j < lb; j++)
		{
			c[i + j] += a[i] * b[j];
		}
	}
	for (int i = 0; i < lc; i++)
	{
		c[i + 1] += c[i] / 10;
		c[i] %= 10;
	}
	while (lc > 1 && c[lc - 1] == 0) lc--;
}

int main()
{
	string x, y; cin >> x >> y;

	la = x.size(); lb = y.size(); lc = la + lb;
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';
	for (int i = 0; i < lb; i++) b[lb - 1 - i] = y[i] - '0';

	mul(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [A/B Problem](https://www.luogu.com.cn/problem/P1480)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10; 

typedef long long LL;

int a[N], b, c[N];
int la, lc;

void div(int c[], int a[], int b)
{
	LL t = 0;
	for (int i = la - 1; i >= 0; i--)
	{
		t = t * 10 + a[i];
		c[i] = t / b;
		t %= b;
	}
	while (lc > 1 && c[lc - 1] == 0) lc--;
}

int main()
{
	string x; cin >> x >> b;

	lc = la = x.size(); 
	for (int i = 0; i < la; i++) a[la - 1 - i] = x[i] - '0';

	div(c, a, b);

	for (int i = lc - 1; i >= 0; i--) cout << c[i];

	return 0;
}
```
# [铺地毯](https://www.luogu.com.cn/problem/P1003)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e4 + 10;

int n;
int a[N], b[N], g[N], k[N];
int x, y;

int find()
{
	for (int i = n; i >= 1; i--)
	{
		if (a[i] <= x && b[i] <= y && x <= a[i] + g[i] && y <= b[i] + k[i])
			return i;
	}
	return -1;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> g[i] >> k[i];
	cin >> x >> y;
	cout << find() << endl;

	return 0;
}
```
# [回文日期](https://www.luogu.com.cn/problem/P2010)
[top](#基础算法)
>1. 法一：枚举 x ~ y 之间的所有数，判断是否是回文，如果是，再拆分成年月日，判断日期是否合法即可

```
```
>2. 法二：仅枚举年份，构成回文形式的日月，判断日期是否合法即可

```
```
>3. 法三：枚举所有日和月的组合，拼成回文日期，判断日期是否合法即可

```
#include <iostream>

using namespace std;

int x, y;
// 9220 是闰年，所以可以直接把二月设成 29 天
int day[] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

int main()
{
	cin >> x >> y;
	int ret = 0; 
	for (int i = 1; i <= 12; i++)
	{
		for (int j = 1; j <= day[i]; j++)
		{
			int k = j % 10 * 1000 + j / 10 * 100 + i % 10 * 10 + i / 10;
			int num = k * 10000 + i * 100 + j;
			if (num >= x && num <= y) ret++;
		}
	}
	cout << ret << endl;

	return 0;
}
```
# [扫雷](https://www.luogu.com.cn/problem/P2327)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e4 + 10;

int n;
int a[N], b[N];

int check1()
{
	a[1] = 0;
	for (int i = 2; i <= n + 1; i++)
	{
		a[i] = b[i - 1] - a[i - 1] - a[i - 2];
		if (a[i] < 0 || a[i] > 1) return 0;
	}
	if (a[n + 1] != 0) return 0;
	return 1;
}

int check2()
{
	a[1] = 1;
	for (int i = 2; i <= n + 1; i++)
	{
		a[i] = b[i - 1] - a[i - 1] - a[i - 2];
		if (a[i] < 0 || a[i] > 1) return 0;
	}
	if (a[n + 1] != 0) return 0;
	return 1;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> b[i];
	int ans = 0;
	ans += check1();
	ans += check2();
	cout << ans << endl;

	return 0;
}
```
# [子集](https://leetcode.cn/problems/subsets/description/)
[top](#基础算法)
法一：二进制
```
class Solution 
{
public:
    vector<vector<int>> subsets(vector<int>& nums) 
    {
        vector<vector<int>> ret;
        int n = nums.size();
        for (int i = 0; i < (1 << n); i++)
        {
            vector<int> tmp;
            for (int j = 0; j < n; j++)
            {
                if ((i >> j) & 1) tmp.push_back(nums[j]);
            }
            ret.push_back(tmp);
        }
        return ret;
    }
};
```
法二：递归
```
```
法三：
```
class Solution 
{
public:
    vector<vector<int>> subsets(vector<int>& nums) 
    {
        vector<vector<int>> ret = {{}};
        for (int i = 0; i < nums.size(); i++) 
        {
            int n = ret.size();
            for (int j = 0; j < n; j++)
            {
                ret.push_back(ret[j]);
                ret.back().push_back(nums[i]);
            }
        }
    return ret;
    }
};
```
# [费解的开关](https://www.luogu.com.cn/problem/P10449)
[top](#基础算法)
```
#include <iostream>
#include <cstring>

using namespace std;

const int N = 10;

int n = 5;
int a[N]; // 用五个数的二进制，表示五排灯的初始状态
int t[N]; // 备份 a 数组，用它来计算

// 计算选择的按法中有多少个 1 （有多少个 1 ，按了多少次）
int calc(int op)
{
	int cnt = 0;
	while (op)
	{
		cnt++;
		op &= op - 1; // 每次去掉最小的那个 1
	}
	return cnt;
}

int main()
{
	int T; cin >> T;
	while (T--)
	{
		// 多组测试，注意清空之前的数据
		memset(a, 0, sizeof a);
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < n; j++)
			{
				char ch; cin >> ch;
				// 存成相反的（是1，存0，不用变；是0，存1，要变）
				if (ch == '0') a[i] |= 1 << j;
			}
		}
		int ret = 7; // 当然，这里写 0x3f3f3f3f（无穷大）也行
		// 枚举第一行的所有按法
		for (int i = 0; i < (1 << n); i++)
		{
			int cnt = 0; // 统计当前按法按的次数
			memcpy(t, a, sizeof a); // 不能直接对 a 数组进行操作
			int op = i; // op 表示当前行的按法
			for (int j = 0; j < n; j++)
			{
				cnt += calc(op);
				t[j] ^= op ^ (op << 1) ^ (op >> 1);
				t[j] &= (1 << n) - 1; // 清空左移过头的影响
				// 修改下一排的状态
				t[j + 1] ^= op;
				// 下一行的按法：要把上一排亮的灯，全部关掉
				op = t[j]; // 把题目从 都变亮->都变暗 的好处之一
			}
			if (t[n - 1] == 0) ret = min(ret, cnt);
		}
		if (ret > 6) cout << -1 << endl;
		else cout << ret << endl;
		
	}

	return 0;
}
```
# [Even Parity](https://www.luogu.com.cn/problem/UVA11464)
[top](#基础算法)
```
#include <iostream>
#include <cstring>

using namespace std;

const int N = 20;

int n;
int a[N], t[N];

int calc(int x, int y)
{
	int cnt = 0;
	for (int i = 0; i < n; i++)
	{
		if (((x >> i) & 1) == 0 && ((y >> i) & 1) == 1) cnt++;
		if (((x >> i) & 1) == 1 && ((y >> i) & 1) == 0) return -1;
	}
	return cnt;
}

int solve()
{
	int ret = 0x3f3f3f3f; // 记录最小的改变次数
	// 枚举第一行的最终状态
	for (int op = 0; op < (1 << n); op++)
	{
		memcpy(t, a, sizeof a);
		int change = op;
		int cnt = 0; // 统计 0 -> 1 的次数
		bool flag = 1;
		for (int i = 1; i <= n; i++)
		{
			// 先判断 change 是否合法
			int c = calc(t[i], change);
			if (c == -1)
			{
				flag = 0;
				break;
			}
			cnt += c; // 累加次数
			// 当前行的最终状态
			t[i] = change;
			// 计算下一行的最终状态
			change = t[i - 1] ^ (t[i] << 1) ^ (t[i] >> 1);
			change &= (1 << n) - 1;
		}
		if (flag) ret = min(ret, cnt);
	}
	if (ret == 0x3f3f3f3f) return -1;
	else return ret;
}

int main()
{
	int T; cin >> T;
	for (int k = 1; k <= T; k++)
	{
		// 多组测试数据，记得清空
		memset(a, 0, sizeof a);
		cin >> n;
		for (int i = 1; i <= n; i++) // 避免越界访问
		{
			for (int j = 0; j < n; j++)
			{
				int x; cin >> x;
				if (x) a[i] |= 1 << j;
			}
		}
		printf("Case %d: %d\n", k, solve());
	}

	return 0;
}
```
# [【模板】前缀和](https://ac.nowcoder.com/acm/problem/226282)
[top](#基础算法)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, q;
int a;
LL f[N];

int main()
{
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        cin >> a;
        f[i] = f[i - 1] + a;
    }
    while (q--)
    {
        int l, r; cin >> l >> r;
        cout << f[r] - f[l - 1] << endl;
    }
    
    return 0;
}
```
# [最大子段和](https://www.luogu.com.cn/problem/P1115)
[top](#基础算法)  
法一：前缀和
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n;
int a, f[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a;
		f[i] = f[i - 1] + a;
	}
	int ans = -1e5;
	int prevmin = 0;
	for (int i = 1; i <= n; i++)
	{
		ans = max(ans, f[i] - prevmin);
		prevmin = min(prevmin, f[i]);
	}
	cout << ans << endl;

	return 0;
}
```
法二：贪心
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n;
int a[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int sum = 0, ans = -1e5;
	for (int i = 1; i <= n; i++)
	{
		sum += a[i];
		ans = max(ans, sum);
		if (sum < 0) sum = 0;
	}
	cout << ans << endl;

	return 0;
}
```
法三：分治
```
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n;
int a[N];

int dfs(int left, int right)
{
	if (left == right) return a[left];

	int mid = left + ((right - left) >> 1);
	int ret = max(dfs(left, mid), dfs(mid + 1, right));

	int lsum = a[mid], lmax = a[mid];
	for (int i = mid - 1; i >= left; i--)
	{
		lsum += a[i];
		lmax = max(lmax, lsum);
	}
	int rsum = a[mid + 1], rmax = a[mid + 1];
	for (int i = mid + 2; i <= right; i++)
	{
		rsum += a[i];
		rmax = max(rmax, rsum);
	}

	return max(ret, lmax + rmax);
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	cout << dfs(1, n) << endl;

	return 0;
}
```
# [【模板】二维前缀和](https://ac.nowcoder.com/acm/problem/226333)
[top](#基础算法)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1010;

int n, m, q;
LL f[N][N];

int main()
{
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int a; cin >> a;
            f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + a;
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        cout << f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1] << endl;
    }
    
    return 0;
}
```
# [激光炸弹](https://www.luogu.com.cn/problem/P2280)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 5010;

int n, m;
int a[N][N], f[N][N];

int main()
{
	cin >> n >> m;
	while (n--)
	{
		int x, y, v; cin >> x >> y >> v;
		a[x + 1][y + 1] += v;
	}
	int sz = 5001;
	for (int i = 1; i <= sz; i++)
	{
		for (int j = 1; j <= sz; j++)
		{
			f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + a[i][j];
		}
	}
	int ans = 0;
	m = min(m, sz);
	for (int i = m; i <= sz; i++)
	{
		for (int j = m; j <= sz; j++)
		{
			ans = max(ans, f[i][j] - f[i - m][j] - f[i][j - m] + f[i - m][j - m]);
		}
	}
	cout << ans << endl;

	return 0;
}
```
>当然，只用一个数组也行
```
#include <iostream>

using namespace std;

const int N = 5010;

int n, m;
int a[N][N];

int main()
{
	cin >> n >> m;
	while (n--)
	{
		int x, y, v; cin >> x >> y >> v;
		a[x + 1][y + 1] += v;
	}
	int sz = 5001;
	for (int i = 1; i <= sz; i++)
	{
		for (int j = 1; j <= sz; j++)
		{
			a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + a[i][j];
		}
	}
	int ans = 0;
	m = min(m, sz);
	for (int i = m; i <= sz; i++)
	{
		for (int j = m; j <= sz; j++)
		{
			ans = max(ans, a[i][j] - a[i - m][j] - a[i][j - m] + a[i - m][j - m]);
		}
	}
	cout << ans << endl;

	return 0;
}
```
# [【模板】差分](https://ac.nowcoder.com/acm/problem/226303)
[top](#基础算法)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, m;
LL a[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
    {
        int x; cin >> x;
        a[i] += x;
        a[i + 1] -= x;
    }
    while (m--)
    {
        int l, r, k; cin >> l >> r >> k;
        a[l] += k;
        a[r + 1] -= k;
    }
    for (int i = 1; i <= n; i++)
    {
        cout << a[i] << ' ';
        a[i + 1] += a[i];
    }
    
    
    return 0;
}
```
# [海底高铁](https://www.luogu.com.cn/problem/P3406)
[top](#基础算法)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, m;
LL f[N];

int main()
{
	cin >> n >> m;
	int x; cin >> x;
	while (m-- - 1)
	{
		int y; cin >> y;
		if (x < y) f[x]++, f[y]--;
		else f[y]++, f[x]--;
		x = y;
	}
	for (int i = 1; i <= n; i++) f[i] += f[i - 1];
	LL ans = 0;
	for (int i = 1; i < n; i++)
	{
		int a, b, c; cin >> a >> b >> c;
		ans += min(a * f[i], c + b * f[i]);
	}
	cout << ans << endl;

	return 0;
}
```
# [【模板】二维差分](https://ac.nowcoder.com/acm/problem/226337)
[top](#基础算法)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1010;

int n, m, q;
LL f[N][N];

int main()
{
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            int x; cin >> x;
            f[i][j] += x, f[i + 1][j] -= x, f[i][j + 1] -= x, f[i + 1][j + 1] += x;
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2, k; cin >> x1 >> y1 >> x2 >> y2 >> k;
        f[x1][y1] += k, f[x1][y2 + 1] -=k, f[x2 + 1][y1] -= k, f[x2 + 1][y2 + 1] += k;
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            f[i][j] += f[i][j- 1] + f[i - 1][j] - f[i - 1][j - 1];
            cout << f[i][j] << ' ';
        }
        cout << endl;
    }
    
    return 0;
}
```
# [地毯](https://www.luogu.com.cn/problem/P3397)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1010;

int n, m;
int f[N][N];

int main()
{
	cin >> n >> m;
	while (m--)
	{
		int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
		f[x1][y1]++, f[x2 + 1][y1]--, f[x1][y2 + 1]--, f[x2 + 1][y2 + 1]++;
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			f[i][j] += f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1];
			cout << f[i][j] << ' ';
		}
		cout << endl;
	}

	return 0;
}
```
# [唯一的雪花 Unique Snowflakes](https://www.luogu.com.cn/problem/UVA11572)
[top](#基础算法)
```
#include <iostream>
#include <unordered_map>

using namespace std;

const int N = 1e6 + 10;

int n;
int a[N];

int main()
{
	int T; cin >> T;
	while (T--)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> a[i];
		int left = 1, right = 1;
		unordered_map<int, int> mp;
		int ans = 1;
		while (right <= n)
		{
			mp[a[right]]++;
			while (mp[a[right]] == 2)
			{
				ans = max(ans, right - left);
				mp[a[left]]--;
				left++;
			}
			right++;
		}
		ans = max(ans, right - left);
		cout << ans << endl;
	}

	return 0;
}


```
# [逛画展](https://www.luogu.com.cn/problem/P1638)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e6 + 10, M = 2e3 + 10;

int n, m;
int a[N];
int kind;
int mp[M];


int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int left = 1, right = 1;
	int begin = 1, ret = n - 1;
	while (right <= n)
	{
		if (mp[a[right]]++ == 0) kind++;
		while (kind == m)
		{
			int len = right - left;
			if (ret > len)
			{
				begin = left;
				ret = len;
			}
			if (mp[a[left]]-- == 1) kind--;
			left++;
		}
		right++;
	}
	cout << begin << ' ' << begin + ret << endl;

	return 0;
}
```
# [字符串](https://ac.nowcoder.com/acm/problem/18386)
[top](#基础算法)
```
#include <iostream>

using namespace std;

string s;
int mp[26];
int kind;

int main()
{
    cin >> s;
    int left = 0, right = 0;
    int len = s.size();
    while (right < s.size())
    {
        if (mp[s[right] - 'a']++ == 0) kind++;
        while (kind == 26)
        {
            len = min(len, right - left + 1);
            if (mp[s[left] - 'a']-- == 1) kind--;
            left++;
        }
        right++;
    }
    cout << len << endl;
    
    return 0;
}
```
# [丢手绢](https://ac.nowcoder.com/acm/problem/207040)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int main()
{
    cin >> n;
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        sum += a[i];
    }
    int left = 1, right = 1;
    int ans = 0, tmp = 0;
    while (right <= n)
    {
        tmp += a[right++];
        while (tmp * 2 > sum)
        {
            ans = max(ans, sum - tmp);
            tmp -= a[left++];
        }
        ans = max(ans, tmp);
    }
    
    cout << ans << endl;
    
    return 0;
}
```
# [牛可乐和魔法封印](https://ac.nowcoder.com/acm/problem/235558)
[top](#基础算法)
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int lower_bound(int target)
{
    int left = -1, right = n;
    while (left + 1 < right)
    {
        int mid = left + ((right - left) >> 1);
        if (a[mid] < target) left = mid;
        else right = mid;
    }
    return right;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    int q; cin >> q;
    while (q--)
    {
        int x, y; cin >>  x >> y;
        int ans = lower_bound(y + 1) - lower_bound(x);
        cout << ans << endl;
    }
    
    return 0;
}
```
# [烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)
[top](#基础算法)  
码一：开区间
```
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int m, n;
int a[N];

int find(int x)
{
	int left = 1, right = m;
	while (left + 1 < right)
	{
		int mid = left + ((right - left) >> 1);
		if (a[mid] < x) left = mid;
		else right = mid;
	}
	return right;
}

int main()
{
	cin >> m >> n;
	for (int i = 1; i <= m; i++) cin >> a[i];
	a[0] = -1e7;
	sort(a + 1, a + 1 + m);
	LL ans = 0;
	while (n--)
	{
		int x; cin >> x;
		int pos = find(x);
		ans += min(abs(a[pos] - x), abs(a[pos - 1] - x));
	}
	cout << ans << endl;

	return 0;
}
```
码二：闭区间
```
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int m, n;
int a[N];

int find(int x)
{
	int left = 1, right = m;
	while (left < right)
	{
		int mid = left + ((right - left) >> 1);
		if (a[mid] < x) left = mid + 1;
		else right = mid;
	}
	return right;
}

int main()
{
	cin >> m >> n;
	for (int i = 1; i <= m; i++) cin >> a[i];
	a[0] = -1e7;
	sort(a + 1, a + 1 + m);
	LL ans = 0;
	while (n--)
	{
		int x; cin >> x;
		int pos = find(x);
		ans += min(abs(a[pos] - x), abs(a[pos - 1] - x));
	}
	cout << ans << endl;

	return 0;
}
```
# [木材加工](https://www.luogu.com.cn/problem/P2440)
[top](#基础算法)  
码一：开区间
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n, k;
int a[N];

int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int left = 0, right = 1e8 + 1;
	while (left + 1 < right)
	{
		int sum = 0;
		int mid = left + ((right - left) >> 1);
		for (int i = 1; i <= n; i++) sum += a[i] / mid;
		if (sum < k) right = mid;
		else left = mid;
	}
	cout << left << endl;

	return 0;
}
```
码二：闭区间
```
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n, k;
int a[N];

int main()
{
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int left = 0, right = 1e8;
	while (left < right)
	{
		int mid = left + ((right - left + 1) >> 1);
		int sum = 0;
		for (int i = 1; i <= n; i++) sum += a[i] / mid;
		if (sum < k) right = mid - 1;
		else left = mid;
	}
	cout << left << endl;

	return 0;
}
```
# [[COCI 2011/2012 #5] EKO / 砍树](https://www.luogu.com.cn/problem/P1873)
[top](#基础算法)  
码一：开区间
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e6 + 10;

int n, m;
int a[N];

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int left = 0, right = 4e5 + 1;
	while (left + 1 < right)
	{
		int mid = left + ((right - left) >> 1);
		LL sum = 0;
		for (int i = 1; i <= n; i++) sum += max(0, a[i] - mid);
		if (sum < m) right = mid;
		else left = mid;
	}
	cout << left << endl;

	return 0;
}
```
码二：闭区间
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e6 + 10;

int n, m;
int a[N];

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int left = 1, right = 4e5;
	while (left < right)
	{
		int mid = left + ((right - left + 1) >> 1);
		LL sum = 0;
		for (int i = 1; i <= n; i++) sum += max(0, a[i] - mid);
		if (sum < m) right = mid - 1;
		else left = mid;
	}
	cout << left << endl;

	return 0;
}
```
# [[NOIP2015 提高组] 跳石头](https://www.luogu.com.cn/problem/P2678)
[top](#基础算法)  
码一：开区间
```
#include <iostream>

using namespace std;

const int N = 5e4 + 10;

int l, n, m;
int a[N];

int main()
{
	cin >> l >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	a[n + 1] = l;
	int left = 1, right = l + 1;
	while (left + 1 < right)
	{
		int mid = left + ((right - left) >> 1);
		int sum = 0;
		for (int i = 0; i <= n; )
		{
			int j = i + 1; 
			while (j <= n + 1 && a[j] - a[i] < mid) j++;
			sum += j - i - 1;
			i = j;
		}
		if (sum <= m) left = mid;
		else right = mid;
	}
	cout << left << endl;

	return 0;
}
```
码二：闭区间
```
#include <iostream>

using namespace std;

const int N = 5e4 + 10;

int l, n, m;
int a[N];

int main()
{
	cin >> l >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	a[n + 1] = l;
	int left = 1, right = l;
	while (left < right)
	{
		int mid = left + ((right - left + 1) >> 1);
		int sum = 0;
		for (int i = 0; i <= n; )
		{
			int j = i + 1; 
			while (j <= n + 1 && a[j] - a[i] < mid) j++;
			sum += j - i - 1;
			i = j;
		}
		if (sum <= m) left = mid;
		else right = mid - 1;
	}
	cout << left << endl;

	return 0;
}
```
# [货仓选址](https://www.luogu.com.cn/problem/P10452)
[top](#基础算法)  
码一：
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int ans = 0;
	for (int i = 1; i <= n; i++) ans += abs(a[i] - a[(n + 1) / 2]); // 这里不能是 a[n / 2]
	cout << ans << endl;

	return 0;
}
```
码二：
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int ans = 0;
	for (int i = 1; i <= n / 2; i++) ans += abs(a[n - i + 1] - a[i]);
	cout << ans << endl;

	return 0;
}
```
# [[NOIP 2007 普及组] 纪念品分组](https://www.luogu.com.cn/problem/P1094)
[top](#基础算法)
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 3e4 + 10;

int w, n;
int a[N];

int main()
{
	cin >> w >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	int left = 1, right = n;
	int ans = 0;
	while (left <= right)
	{
		if (a[left] + a[right] <= w) left++, right--;
		else right--;
		ans++;
	}
	cout << ans << endl;

	return 0;
}
```
# [[NOIP 2008 普及组] 排座椅](https://www.luogu.com.cn/problem/P1056)
[top](#基础算法)
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int m, n, k, l, d;

struct node
{
	int index;
	int cnt;
}row[N], col[N];

// 按照 cnt 从大到小排序
bool cmp1(node& x, node& y)
{
	return x.cnt > y.cnt;
}

// 按照 index 从小到大排序
bool cmp2(node& x, node& y)
{
	return x.index < y.index;
}

int main()
{
	cin >> m >> n >> k >> l >> d;
	for (int i = 1; i <= m; i++) row[i].index = i;
	for (int i = 1; i <= n; i++) col[i].index = i;
	while (d--)
	{
		int x, y, p, q; cin >> x >> y >> p >> q;
		if (x == p) col[min(y, q)].cnt++;
		else row[min(x, p)].cnt++;
	}
	sort(row + 1, row + 1 + m, cmp1);
	sort(col + 1, col + 1 + n, cmp1);

	sort(row + 1, row + 1 + k, cmp2);
	sort(col + 1, col + 1 + l, cmp2);
	for (int i = 1; i <= k; i++) cout << row[i].index << ' ';
	cout << endl;
	for (int i = 1; i <= l; i++) cout << col[i].index << ' ';
	cout << endl;

	return 0;
}
```
# [矩阵消除游戏](https://ac.nowcoder.com/acm/problem/200190)
[top](#基础算法)
>行的选择会影响列，不能直接贪心。
例：  
```
200   1   100
0     0   0
200   1   100
```
>可以先二进制枚举行，再用贪心处理列
```
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 20;

int n, m, k;
int a[N][N];
int col[N];

int calc(int op)
{
    int ret = 0;
    while (op)
    {
        op &= (op - 1);
        ret++;
    }
    return ret;
}

bool cmp(int a, int b)
{
    return a > b;
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> a[i][j];
    
    int ans = 0;
    for (int op = 0; op < (1 << n); op++)
    {
        int cnt = calc(op);
        if (cnt > k) continue;
        
        memset(col, 0, sizeof col);
        int sum = 0;
        for (int i = 0; i <= n; i++)
        {
            for (int j = 0; j <= m; j++)
            {
                if ((op >> i) & 1) sum += a[i][j];
                else col[j] += a[i][j];
            }
        }
        sort(col, col + m, cmp);
        for (int i = 0; i < k - cnt; i++) sum += col[i];
        ans = max(ans, sum);
    }
    cout << ans << endl;
    
    return 0;
}
```
# [[NOIP 1998 提高组] 拼数](https://www.luogu.com.cn/problem/P1012)
[top](#基础算法)
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 25;

int n;
string a[N];

bool cmp(string x, string y)
{
	return x + y > y + x;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + 1 + n, cmp);
	for (int i = 1; i <= n; i++) cout << a[i];

	return 0;
}
```
# [[USACO07JAN] Protecting the Flowers S](https://www.luogu.com.cn/problem/P2878)
[top](#基础算法)
```
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n;
struct node
{
	int t;
	int d;
}a[N];

bool cmp(node& x, node& y)
{
	return x.t * y.d < y.t * x.d;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i].t >> a[i].d;
	sort(a + 1, a + 1 + n, cmp);
	LL ans = 0, t = 0;
	for (int i = 1; i <= n; i++)
	{
		ans += a[i].d * t;
		t += 2 * a[i].t;
	}
	cout << ans << endl;

	return 0;
}
```
# [[USACO05NOV] 奶牛玩杂技](https://www.luogu.com.cn/problem/P1842)
[top](#基础算法)
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 5e4 + 10;

int n;
struct node
{
	int w;
	int s;
}a[N];

bool cmp(node& x, node& y)
{
	return x.w - y.s < y.w - x.s;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i].w >> a[i].s;
	sort(a + 1, a + 1 + n, cmp);
	int ans = -1e9, w = 0;
	for (int i = 1; i <= n; i++)
	{
		ans = max(ans, w - a[i].s);
		w += a[i].w;
	}
	cout << ans << endl;

	return 0;
}
```
# [【模板】哈夫曼编码](https://ac.nowcoder.com/acm/problem/233601)
[top](#基础算法)
```
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

typedef long long LL;

const int N = 2e5 + 10;

int n;
priority_queue<LL, vector<LL>, greater<LL>> heap;

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        int x; cin >> x;
        heap.push(x);
    }
    LL ans = 0;
    while (heap.size() > 1)
    {
        LL x = heap.top(); heap.pop();
        LL y = heap.top(); heap.pop();
        ans += x + y;
        heap.push(x + y);
    }
    cout << ans << endl;
    
    return 0;
}
```
# [[NOIP 2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)
[top](#基础算法)
```
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

const int N = 1e4 + 10;

int n;
priority_queue<int, vector<int>, greater<int>> heap;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) 
	{
		int x; cin >> x;
		heap.push(x);
	}
	int ans = 0;
	while (heap.size() > 1)
	{
		int x = heap.top(); heap.pop();
		int y = heap.top(); heap.pop();
		ans += x + y;
		heap.push(x + y);
	}
	cout << ans << endl;
	
	return 0;
}
```
# [凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
[top](#基础算法)
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e6 + 10;

int n;
struct node
{
	int l;
	int r;
}a[N];

bool cmp(node& x, node& y)
{
	return x.l < y.l;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i].l >> a[i].r;
	sort(a + 1, a + 1 + n, cmp);
	int ans = 1;
	int r = a[1].r;
	for (int i = 2; i <= n; i++)
	{
		if (r > a[i].l) r = min(r, a[i].r);
		else
		{
			ans++;
			r = a[i].r;
		}
	}
	cout << ans << endl;

	return 0;
}
```
# [Radar Installation](https://www.luogu.com.cn/problem/UVA1193)
[top](#8-贪心)
```
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 1010;

int n, d;
struct node
{
	double l, r;
}a[N];

bool cmp(node& x, node& y)
{
	return x.l < y.l;
}

int main()
{
	int cnt = 0;
	while (cin >> n >> d, n || d)
	{
		cnt++;
		bool flag = false;
		for (int i = 1; i <= n; i++)
		{
			int x, y; cin >> x >> y;
			if (d < y)
			{
				flag = true;
				break;
			}
			double l = sqrt(d * d - y * y);
			a[i].l = x - l, a[i].r = x + l;
		}
		cout << "Case " << cnt << ": ";
		if (flag) cout << -1 << endl;
		else
		{
			sort(a + 1, a + 1 + n, cmp);
			int ans = 1;
			double r = a[1].r;
			for (int i = 2; i <= n; i++)
			{
				if (r >= a[i].l) r = min(r, a[i].r);
				else
				{
					ans++;
					r = a[i].r;
				}
			}
			cout << ans << endl;
		}
	}

	return 0;
}
```
# [[USACO07NOV] Sunscreen G](https://www.luogu.com.cn/problem/P2887)
>奶牛排序要错开来，可以有重叠的部分，但一定不能有包含关系：可以左降 / 右升  
>防晒霜排序要跟奶牛排序一样：降 / 升  

[top](#8-贪心)  
码一：
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2510;

int c, l;
struct node
{
	int x; // minSPFi / SPFi
	int y; // maxSPFi / coveri
}a[N], b[N];

bool cmp(node& x, node& y)
{
	return x.x > y.x;
}

int main()
{
	cin >> c >> l;
	for (int i = 1; i <= c; i++) cin >> a[i].x >> a[i].y;
	for (int i = 1; i <= l; i++) cin >> b[i].x >> b[i].y;
	sort(a + 1, a + 1 + c, cmp);
	sort(b + 1, b + 1 + l, cmp);
	int ans = 0;
	for (int i = 1; i <= c; i++)
	{
		for (int j = 1; j <= l; j++)
		{
			if (b[j].y == 0) continue; // 防晒霜没了
			if (b[j].x < a[i].x) break; // 最大的都强度太小
			if (b[j].x > a[i].y) continue; // 强度大了
			// 满足条件
			ans++;
			b[j].y--;
			break;
		}
	}
	cout << ans << endl;

	return 0;
}
```
码二：
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2510;

int c, l;
struct node
{
	int x; // minSPFi / coveri
	int y; // maxSPFi / SPFI
}a[N], b[N];

bool cmp(node& x, node& y)
{
	return x.y < y.y;
}

int main()
{
	cin >> c >> l;
	for (int i = 1; i <= c; i++) cin >> a[i].x >> a[i].y;
	for (int i = 1; i <= l; i++) cin >> b[i].y >> b[i].x;
	sort(a + 1, a + 1 + c, cmp);
	sort(b + 1, b + 1 + l, cmp);
	int ans = 0;
	for (int i = 1; i <= c; i++)
	{
		for (int j = 1; j <= l; j++)
		{
			if (b[j].x == 0) continue; // 防晒霜没了
			if (b[j].y > a[i].y) break; // 最小的都强度太大
			if (b[j].y < a[i].x) continue; // 强度小了
			// 满足条件
			ans++;
			b[j].x--;
			break;
		}
	}
	cout << ans << endl;

	return 0;
}
```
# [[USACO06FEB] Stall Reservations S](https://www.luogu.com.cn/problem/P2859)
[top](#8-贪心)
```
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 5e4 + 10;

int n;
struct node
{
	int x; // 产奶起始时间 / 挤奶终止时间
	int y; // 产奶结束时间 / 牛棚编号
	int z; // 奶牛编号

	bool operator<(const node& t) const
	{
		return x > t.x;
	}
}a[N];

bool cmp(node& x, node& y)
{
	return x.x < y.x;
}

int ans[N]; // 存最终结果

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i].x >> a[i].y;
		a[i].z = i;
	}
	sort(a + 1, a + 1 + n, cmp); // 按起始时间从小到大排序
	int cnt = 1; // 牛棚数量
	priority_queue<node> heap; // 按结束时间排序的小根堆
	ans[a[1].z] = 1;
	heap.push({ a[1].y, 1 });
	for (int i = 2; i <= n; i++)
	{
		if (a[i].x <= heap.top().x) // 无法放在已分配奶牛的牛棚里
		{
			// 重新分配新的牛棚
			cnt++;
			heap.push({ a[i].y, cnt });
			ans[a[i].z] = cnt;
		}
		else // 可以放在已经分配奶牛的牛棚里
		{
			ans[a[i].z] = heap.top().y;
			// 更新 heap
			heap.pop();
			heap.push({ a[i].y, ans[a[i].z] });
		}
	}
	cout << cnt << endl;
	for (int i = 1; i <= n; i++) cout << ans[i] << endl;

	return 0;
}
```
# [【模板】快速幂](https://www.luogu.com.cn/problem/P1226)
[top](#9-倍增思想)  
>补充：取模运算
>1. 加法和乘法：取模可以放在任意位置，只要在最后取了一次模就行
>2. 减法：结果可能是负数，采取模加模 —— ((a - b) % p + p) % p
>3. 除法：取模会得出错误结果 —— 求逆元
```
#include <iostream>

using namespace std;

typedef long long LL;

LL a, b, p;

LL qpow(LL a, LL b, LL p)
{
	LL ret = 1;
	while (b)
	{
		if (b & 1) ret = ret * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return ret;
}

int main()
{
	cin >> a >> b >> p;
	printf("%lld^%lld mod %lld=%lld", a, b, p, qpow(a, b, p));

	return 0;
}
```
# [64位整数乘法](https://www.luogu.com.cn/problem/P10446)
[top](#9-倍增思想)
```
#include <iostream>

using namespace std;

typedef long long LL;

LL a, b, p;

LL qmul(LL a, LL b, LL p)
{
	LL ret = 0;
	while (b)
	{
		if (b & 1) ret = (ret + a) % p;
		a = (a + a) % p;
		b >>= 1;
	}
	return ret;
}

int main()
{
	cin >> a >> b >> p;
	cout << qmul(a, b, p) << endl;

	return 0;
}
```
# [火烧赤壁](https://www.luogu.com.cn/problem/P1496)
[top](#10-离散化)  
码一：
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2e4 + 10;

int n; // 起火的信息条数
int a[N], b[N]; // 着火位置的起点和终点

int pos; // 离散化后的数组大小
int disc[N * 2]; // 帮助离散化 a[N], b[N]，通过离散后的值（下标 i）找到离散前的值（a[i], b[i]）

int f[N * 2]; // 差分数组

// 通过离散前的值（a[i], b[i]）找到离散后的值（下标）
int find(int x)
{
	int left = 0, right = pos;
	while (left + 1 < right)
	{
		int mid = left + ((right - left) >> 1);
		if (disc[mid] < x) left = mid;
		else right = mid;
	}
	return right;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i] >> b[i];
		disc[++pos] = a[i], disc[++pos] = b[i];
	}

	// 离散化
	sort(disc + 1, disc + 1 + pos); // 排序
	pos = unique(disc + 1, disc + 1 + pos) - (disc + 1); // 去重

	// 在离散化过的基础上做差分
	for (int i = 1; i <= n; i++)
	{
		// a[i] ～ b[i]
		int l = find(a[i]), r = find(b[i]);
		f[l]++, f[r]--;
	}

	// 还原差分
	for (int i = 1; i <= pos; i++) f[i] += f[i - 1];

	// 统计结果
	int ans = 0;
	for (int i = 1; i <= pos; i++)
	{
		int j = i;
		while (j <= pos && f[j] > 0) j++;
		// 累加上原始的长度
		ans += disc[j] - disc[i];
		i = j;
	}

	cout << ans << endl;

	return 0;
}
```
码二：  
```
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 2e4 + 10;

int n; // 起火的信息条数
int a[N], b[N]; // 着火位置的起点和终点

int pos; // 离散化后的数组大小
int disc[N * 2]; // 帮助离散化 a[N], b[N]，通过离散后的值（下标 i）找到离散前的值（a[i], b[i]）
unordered_map<int, int> id; // <离散前的值， 离散后的值>，通过离散前的值找到离散后的值

int f[N * 2]; // 差分数组

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i] >> b[i];
		disc[++pos] = a[i], disc[++pos] = b[i];
	}

	// 离散化
	sort(disc + 1, disc + 1 + pos); // 排序
	pos = unique(disc + 1, disc + 1 + pos) - (disc + 1); // 去重
	for (int i = 1; i <= pos; i++)
	{
		id[disc[i]] = i; // 哈希表仅需完成保存离散化后的结果
	}

	// 在离散化过的基础上做差分
	for (int i = 1; i <= n; i++)
	{
		// a[i] ～ b[i]
		int l = id[a[i]], r = id[b[i]];
		f[l]++, f[r]--;
	}

	// 还原
	for (int i = 1; i <= pos; i++) f[i] += f[i - 1];

	// 统计结果
	int ans = 0;
	for (int i = 1; i <= pos; i++)
	{
		int j = i;
		while (j <= pos && f[j] > 0) j++;
		// 累加上原始的长度
		ans += disc[j] - disc[i];
		i = j;
	}

	cout << ans << endl;

	return 0;
}
```
# [[HAOI2014] 贴海报](https://www.luogu.com.cn/problem/P3740)
[top](#10-离散化)  
>A - B 是区间，直接离散化会把区间变成点，少了区间内部与区间之间的空隙  
>为了解决这个问题，我们可以在离散化的区 [A, B] 时，不仅考虑A，B这两个值，也把 A + 1, B + 1 也考虑进去  

码一：
```
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int a[N], b[N];

int pos;
int disc[N * 4];

int w[N * 4]; // electoral 墙
bool st[N]; // 标记哪些海报已被标记

int find(int x)
{
	int l = 0, r = pos;
	while (l + 1 < r)
	{
		int mid = l + ((r - l) >> 1);
		if (disc[mid] < x) l = mid;
		else r = mid;
	}
	return r;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		cin >> a[i] >> b[i];
		disc[++pos] = a[i], disc[++pos] = a[i] + 1;
		disc[++pos] = b[i], disc[++pos] = b[i] + 1;
	}
	sort(disc + 1, disc + 1 + pos);
	pos = unique(disc + 1, disc + 1 + pos) - (disc + 1);
	for (int i = 1; i <= m; i++)
	{
		// a[i] ～ b[i]
		int left = find(a[i]), right = find(b[i]);
		for (int j = left; j <= right; j++)
		{
			w[j] = i;
		}
	}
	int ans = 0;
	for (int i = 1; i <= pos; i++)
	{
		int x = w[i];
		if (!x || st[x]) continue;
		ans++;
		st[x] = true;
	}
	cout << ans << endl;

	return 0;
}
```
码二：
```
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 1010;

int n, m;
int a[N], b[N];

int pos;
int disc[N * 4];
unordered_map<int, int> id;

int w[N * 4]; // electoral 墙
bool st[N]; // 标记哪些海报已被标记


int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		cin >> a[i] >> b[i];
		disc[++pos] = a[i], disc[++pos] = a[i] + 1;
		disc[++pos] = b[i], disc[++pos] = b[i] + 1;
	}
	sort(disc + 1, disc + 1 + pos);
	int cnt = 0;
	for (int i = 1; i <= pos; i++)
	{
		int x = disc[i];
		if (id.count(x)) continue;
		id[x] = ++cnt;
	}
	for (int i = 1; i <= m; i++)
	{
		// a[i] ～ b[i]
		int left = id[a[i]], right = id[b[i]];
		for (int j = left; j <= right; j++)
		{
			w[j] = i;
		}
	}
	int ans = 0;
	for (int i = 1; i <= cnt; i++)
	{
		int x = w[i];
		if (!x || st[x]) continue;
		ans++;
		st[x] = true;
	}
	cout << ans << endl;

	return 0;
}
```
# [汉诺塔问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1205)
[top](#11-递归初阶)
```
#include <iostream>

using namespace std;

int n;
char a, b, c;

// 把 x 柱子上的 n 个盘子，借助 y 的帮助，全部放到 z 上
void dfs(int n, char x, char y, char z)
{
	if (!n) return;
	dfs(n - 1, x, z, y);
	printf("%c->%d->%c\n", x, n, z);
	dfs(n - 1, y, x, z);
}

int main()
{
	cin >> n >> a >> b >> c;
	dfs(n, a, c, b);

	return 0;
}
```
# [占卜DIY](https://www.luogu.com.cn/problem/P10457)
[top](#11-递归初阶)
```
#include <iostream>

using namespace std;

int n = 13, m = 4;
int a[14][5];
int cnt[14]; // 统计每堆牌中正面朝下的牌的个数

void dfs(int x)
{
	if (x == 13) return;
	int t = a[x][cnt[x]];
	cnt[x]--;
	dfs(t);
}

int main()
{
	for (int i = 1; i <= n; i++)
	{
		cnt[i] = 4;
		for (int j = 1; j <= m; j++)
		{
			char ch; cin >> ch;
			if (ch >= '2' && ch <= '9') a[i][j] = ch - '0';
			else if (ch == 'A') a[i][j] = 1;
			else if (ch == '0') a[i][j] = 10;
			else if (ch == 'J') a[i][j] = 11;
			else if (ch == 'Q') a[i][j] = 12;
			else a[i][j] = 13;
		}
	}

	for (int i = 1; i <= m; i++)
	{
		dfs(a[n][i]);
	}

	int ans = 0;
	for (int i = 1; i <= n; i++)
	{
		if (!cnt[i]) ans++;
	}
	cout << ans << endl;

	return 0;
}
```
# [[NOIP 2004 普及组] FBI 树](https://www.luogu.com.cn/problem/P1087)
[top](#11-递归初阶)  
码一：
```
#include <iostream>

using namespace std;

int n;
int a[1 << 11]; // 前缀和数组

void dfs(int left, int right)
{
	// 判断类型
	char ret;
	int sum = a[right] - a[left - 1];
	if (!sum) ret = 'B';
	else if (sum == right - left + 1) ret = 'I';
	else ret = 'F';

	if (left == right) // 不存在 left > right
	{
		cout << ret;
		return;
	}

	int mid = left + ((right - left) >> 1);
	dfs(left, mid), dfs(mid + 1, right);
	cout << ret;
}

int main()
{
	cin >> n;
	n = (1 << n);
	for (int i = 1; i <= n; i++)
	{
		char ch; cin >> ch;
		if (ch == '1') a[i] = 1;
		a[i] += a[i - 1];
	}

	dfs(1, n);

	return 0;
}
```
>其实根节点的类型其实只与左右子树有关，故可写出下面的代码

码二：
```
#include <iostream>

using namespace std;

int n;
int a[1 << 11];

char dfs(int left, int right)
{
	if (left == right)
	{
		char ret = a[left] ? 'I' : 'B';
		cout << ret;
		return ret;
	}
	int mid = left + ((right - left) >> 1);
	char x = dfs(left, mid), y = dfs(mid + 1, right);
	char ret = (x == y) ? x : 'F';
	cout << ret;
	return ret;
}

int main()
{
	cin >> n;
	n = (1 << n);
	for (int i = 1; i <= n; i++)
	{
		char ch; cin >> ch;
		if (ch == '1') a[i] = 1;
	}

	dfs(1, n);

	return 0;
}
```
# [逆序对](https://www.luogu.com.cn/problem/P1908)
[top](#12-分治)
```
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 5e5 + 10;

int n;
int a[N];
int tmp[N];

LL merge(int left, int right)
{
	if (left == right) return 0;
	LL ret = 0;
	int mid = left + ((right - left) >> 1);
	ret += merge(left, mid) + merge(mid + 1, right);
	int i = left, cur1 = left, cur2 = mid + 1;
	while (cur1 <= mid && cur2 <= right)
	{
		if (a[cur1] <= a[cur2]) tmp[i++] = a[cur1++];
		else
		{
			ret += mid - cur1 + 1;
			tmp[i++] = a[cur2++];
		}
	}
	while (cur1 <= mid) tmp[i++] = a[cur1++];
	while (cur2 <= right) tmp[i++] = a[cur2++];
	for (int j = left; j <= right; j++) a[j] = tmp[j];
	return ret;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	cout << merge(1, n) << endl;

	return 0;
}
```
# [【深基9.例4】求第 k 小的数](https://www.luogu.com.cn/problem/P1923)
[top](#12-分治)
```
#include <iostream>
#include <ctime>

using namespace std;

const int N = 5e6 + 10;

int n, k;
int a[N];

int get_random(int left, int right)
{
	return a[rand() % (right - left + 1) + left];
}

int quick_select(int left, int right, int k)
{
	if (left == right) return a[left];

	// 选择基准元素
	int p = get_random(left, right);

	// 数组分三块
	// [left, l] [l + 1, r - 1] [r, right]
	int l = left - 1, i = left, r = right + 1;
	while (i < r)
	{
		if (a[i] < p) swap(a[++l], a[i++]);
		else if (a[i] == p) i++;
		else swap(a[--r], a[i]);
	}
	
	// 选择存在最终结果的区间
	int a = l - left + 1, b = r - 1 - l;
	if (k <= a) return quick_select(left, l, k);
	if (k <= a + b) return p;
	return quick_select(r, right, k - a - b);
}

int main()
{
	srand(time(0));
	scanf("%d%d", &n, &k);
	k++;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	printf("%d\n", quick_select(1, n, k));

	return 0;
}
```
# [地毯填补问题](https://www.luogu.com.cn/problem/P1228)
[top](#12-分治)
```
#include <iostream>

using namespace std;

int k, x, y;

void dfs(int a, int b, int x, int y, int len)
{
	if (len == 1) return;

	len /= 2;
	if (x < a + len && y < b + len) // 障碍物在左上角
	{
		cout << a + len << ' ' << b + len << ' ' << 1 << endl;
		dfs(a, b, x, y, len);
		dfs(a, b + len, a + len - 1, b + len, len); // 处理右上
		dfs(a + len, b, a + len, b + len - 1, len); // 处理左下
		dfs(a + len, b + len, a + len, b + len, len); // 处理右下
	}
	else if (x < a + len) // 障碍物在右上角
	{
		cout << a + len << ' ' << b + len - 1 << ' ' << 2 << endl;
		dfs(a, b + len, x, y, len);
		dfs(a, b, a + len - 1, b + len - 1, len); // 处理左上
		dfs(a + len, b, a + len, b + len - 1, len);
		dfs(a + len, b + len, a + len, b + len, len);
	}
	else if (y < b + len) // 障碍物在左下角
	{
		cout << a + len - 1 << ' ' << b + len << ' ' << 3 << endl;
		dfs(a + len, b, x, y, len);
		dfs(a, b, a + len - 1, b + len - 1, len);
		dfs(a, b + len, a + len - 1, b + len, len);
		dfs(a + len, b + len, a + len, b + len, len);
	}
	else // 障碍物在右下角
	{
		cout << a + len - 1 << ' ' << b + len - 1 << ' ' << 4 << endl;
		dfs(a + len, b + len, x, y, len);
		dfs(a, b, a + len - 1, b + len - 1, len);
		dfs(a, b + len, a + len - 1, b + len, len);
		dfs(a + len, b, a + len, b + len - 1, len);
	}
}

int main()
{
	cin >> k >> x >> y;
	k = (1 << k);
	dfs(1, 1, x, y, k);

	return 0;
}
```
