# 算法巩固

#### 2025年03月
* [CF44C Holidays](#cf44c-holidays)
* [[NOIP 2014 普及组] 螺旋矩阵](#noip-2014-普及组-螺旋矩阵)


# [CF44C Holidays](https://www.luogu.com.cn/problem/CF44C)  
[top](#2025年03月)  
```
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n, m;
int st[N];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int a, b; cin >> a >> b;
		for (int j = a; j <= b; j++) {
			st[j]++;
		}
	}
	
	for (int i = 1; i <= n; i++) {
		if (st[i] == 1) continue;
		cout << i << ' ' << st[i] << endl;
		return 0;
	}
	
	cout << "OK" << endl;
	
	return 0;
} 
```
>优化：
[a[i], b[i]] 天浇水，相当于这些天的浇水次数加一，一段区间整体加一，可以用差分
```
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n, m;
int f[N];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int a, b; cin >> a >> b;
		// 差分 
		f[a]++, f[b + 1]--;
	}
	
	// 前缀和 
	for (int i = 1; i <= n; i++) {
		f[i] += f[i - 1];
		if (!f[i] || f[i] > 1) {
			cout << i << ' ' << f[i] << endl;
			return 0;
		}
	}
	
	cout << "OK" << endl;
	
	return 0;
} 
```
# [[NOIP 2014 普及组] 螺旋矩阵](https://www.luogu.com.cn/problem/P2239)
[top](#2025年03月)  
>很像 [【深基5.习6】蛇形方阵](https://www.luogu.com.cn/problem/P5731) ，但这道题 n 的范围很大，空间不够，会导致栈溢出，所以不能暴力模拟  

>解法：递归 -> 把矩阵分成一圈一圈的，从外向内找，当这一圈里有要找的数，就返回；  
```dfs(int n, int begin, int i, int j)```  
n 表示矩阵大小，begin 表示这一圈的矩阵从那个数开始计算，i 和 j 是要找的数的坐标  
如果这一圈没找到，就返回  
```dfs(n - 2, begin + (n - 1) * 4, i - 1, j - 1)```  
n - 2 是因为少了一圈就少了上下左右的边；  
(n - 1) * 4 是这一圈的数字个数；  
i - 1，j - 1 是因为少了左边和上边那一层  
如果这一圈存在要找的数，i == 1 || j == n || i == n || j == 1  
i == 1 -> begin + j  
j == n -> begin + (n - 1) + i  
i == n -> begin + (n - 1) * 2 + (n - j + 1)  
j == 1 -> begin + (n - 1) * 3 + (n - i + 1)  
```
#include <bits/stdc++.h>

using namespace std;

int n, i, j;

int dfs(int n, int begin, int i, int j) {
	if (i == 1) return begin + j;
	else if (j == n) return begin + n - 1 + i;
	else if (i == n) return begin + n * 3 - 1 - j;
	else if (j == 1) return begin + n * 4 - 2 - i;
	return dfs(n - 2, begin + (n - 1) * 4, i - 1, j - 1);
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> i >> j;
	cout << dfs(n, 0, i, j) << endl;
	
	return 0;
} 
```
